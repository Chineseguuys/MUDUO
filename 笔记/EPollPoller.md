# EPollPoller 的基本工作流程

## 水平触发和边沿触发

### 水平触发

水平触发从名字就可以看出来，是在监控的文件描述符上有可以读写的事件发生的时候，调用 ```epoll_wait()``` 函数就会被通知有可以读写。如果你在上一次读写的过程中，数据没有一次性读写完（可能是读写的缓冲区太小，一次没有取出所有的数据） ，那么你在下一次调用 ```epoll_wait()``` 的时候，还会收到通知，如果你一直不去读写的话，那么就会一直被通知

### 边沿触发

顾名思义，边沿触发在状态发生变化的时候触发。当被监控的文件描述符上有可读写的事件发生的时候， ```epoll_wait()``` 会通知用户去进行相应的操作，如果你没有将数据全部操作完，那么下一次调用 ```epoll_wait()``` 将不会发出通知了，除非在这个文件描述符上发生了新的读写事件，这个时候才会再次发出通知


### Select, Poll, Epoll 的触发方式

select, poll 都只支持水平触发的方式

epoll 支持水平触发和边沿触发两种触发方式，在实际的应用当中，往往边沿触发的方式更加具有优势。它可以减少应用处理 I/O 事件的次数

默认的情况下，采用是<font color=red>水平触发的方式</font>


## Select, Poll, Epoll 有什么区别？

首先这三者都是负责 I/O 非阻塞多路复用的事件监测。它们都是采用轮询的方式进行处理。

select 每次调用都要重新添加文件描述符（<font color=red>select 函数返回的时候，集合中没有发生事件的文件描述符会被移除</font>），操作比较的复杂。还需要知道监测的最大的文件描述符的数值。因此为了效率，select 对于监测的文件描述符的数量有最大值的限制

poll 没有必要计算监测的文件描述符的最大值了，但是也需要每一次查询的时候传递所有的文件描述符 (```pollfd* fds```)。 函数返回的时候，需要自己手动的遍历所有的 ```pollfd``` ，查看每一个文件描述符是否有事件发生

poll 相比于 select 可以监测的事件更加的多，select 可以监测的事件有三类，可读，可写，异常。 poll 更加复杂

触发方式上的不同

epoll 发生事件的文件描述符会自动进行排序，不需要自己去查看每一个文件描述符是否有事件发生。epoll 和 poll 将 event 和 revent 分离开来，(select 通过移除没有发生事件的文件描述符来返回发生事件的文件描述符)

