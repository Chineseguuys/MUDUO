# Linux 时间

Linux 操作系统有三个时间：

1. 真实时间：这个时间是现实当中使用的时间，这个时间是用户可以进行修改的，或者通过网络来进行修改，所以这个时间是不可靠的，所以一般不使用这个时钟

2. 单调时间 : 这个时间是严格增长的时间，这个时间从操作系统开机的时候开始计时，一直不断的增长。这个时间是精确的，不会像真实时间一样会发生改变

3. 进程时间： 进程消耗的时间，这个时间也是不精确的，是一个大概的值


## 相对时间和绝对时间

1. 相对时间 是从某一个基准开始的一段时间
2. 绝对时间 不包含任何基准的时间。Linux 使用从 1970-1-1-00:00:00 到新再的秒数来表示绝对时间。从这里可以看出，绝对时间实际上也是相对的

## ```time_t``` 

<font color=red>time_t 表示从大纪元开始到现在所经过的秒数（注意，这个秒数不一定就是真的从大纪元开始到现在的秒数，操作系统没有对这个数值进行精确的计算，但是不要紧，操作系统需要保证的是这个数据的一致性（用它来计算相对时间是精确的）而不是正确性）</font>

## ```timeval``` 

在现代操作系统下面，1s 只内可以发生很多的事情，所以我们需要将 秒再进行细分

```c
struct timeval
{
  __time_t tv_sec;		/* Seconds.  */
  __suseconds_t tv_usec;	/* Microseconds. 微秒  1000*1000 */
};
```

## ```timespec```

提供纳秒级别的时间，CPU 的操作在纳秒级别

```c
time_t time(time_t *t);
/**
 * 返回当前的系统的绝对时间（从大纪元开始的时间）
*/
```

```c
int gettimeofday(struct timeval* tv, struct timezone* tz);
/**
 * timezone 是一个非常老的参数，现在几乎都不在使用了，所以这个函数的一般的使用方法都是传递第一个参数，忽略第二个参数
*/
```

## 睡眠和等待

### 秒级别的睡眠

```c
unsigned int sleep(unsigned int seconds);
/**
 * 这个函数返回的是未睡眠的秒数，实际上用户使用这个函数不一定关注程序睡眠了多久，所以往往不检查返回值的大小
*/
```

### 微秒级别的睡眠

```c
void usleep(unsigned long usec);
/**
 * linux 并不赞成使用 usleep() 函数
*/
```

### 纳秒级别的睡眠

```c
int nanosleep(const struct timespec* req, struct timespec* rem);
/**
 * req 提供睡眠的时间， rem 记录剩余睡眠时间。你可以第二次使用 nanosleep 函数 rem 传递给 req
*/
```

## 睡眠超限

除了出现了错误，往往睡眠的时间都会长于设定的时间。原因很简单，睡眠的时间已经过去了，内核也已经及时的唤醒了进程，但是调度器并不在调度当前的进程，当前的进程在就绪队列中需要等待一段时间。

## 定时器

```c
unsigned int alarm(unsigned int seconds);
```

这个定时器在设定了的时间到达之后，将信号 ```SIGALRM``` 发送给调用的进程，这个进程可以处理这个信号。

* 这个定时器是非阻塞的，如果在定时时间之内进程停止退出，那么这个定时器就没有效果

* 需要在 信号处理函数中对定时的事件进行处理

