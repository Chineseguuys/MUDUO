## 1. 如果要主动的关闭连接，如何保证对方可以接收到所有的数据？

数据的发送时用户主动发起的行为，但是何时进行发送，确是 epoll 中的事件和 channel 来共同决定的。

* epoll 和 channel 只负责处理输出缓冲区中的数据，当输出缓冲区中有数据的时候，使用 channel 的 回调进行发送，如果输出缓冲区没有数据，那么 ```channel->disableWritting()``` ,也就是说，epoll 不监测这个 socket 是否可写

* 有新的数据需要发送，首先直接通过 socket 进行发送（绕过发送缓冲区），只有当数据量太大了，一次性发送不完，需要存在缓冲区的时候，我们将数据存在缓冲区，设置 ```channel->enableWritting()``` ,使用 epoll 监测 socket 的可写状态，使用 藏annel 的回调函数发送缓冲区的数据

从 socket 中读取数据一定是存储到输入缓冲区内，之后通过回调函数通知上层的模块提取这些数据


关闭的过程

### ```TcpConnetion::shutDown()```

> 这个函数希望可以关闭 Tcp 发送数据的一端，但是如果缓冲区还有数据，这个函数无法关闭写端

> 但是连接的状态发生了改变，从 ```Connected``` 变为了 ```DisConnecting```。那么在缓冲区内的数据全部发送完之后，自然会关闭写端（回答了问题 1）

> 状态变为了 ```DisConnecting``` ，但是 socket 依然可以接收数据

